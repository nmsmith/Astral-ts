import * as FuzzyDict from "./fuzzy-prefix-dict"

export interface ConceptRegistry {
    readonly namesDict: FuzzyDict.T<Concept>
    readonly autoLabelPrefix: string
    nextAutoLabel: number
}

export type T = ConceptRegistry

// Currently, concepts are uniquely identified by their address.
// For a distributed system, (under the hood) identity will need
// to be established via some kind of conflict-free UUID.
export interface Concept {
    readonly label: string // source of truth
    readonly registry: ConceptRegistry
}

export type SearchResult = FuzzyDict.SearchResult<Concept>

/**
 * Create a new concept registry.
 * Autogenerated concept labels will have the given label prefix.
 */
export function empty(autoLabel: string): ConceptRegistry {
    return {
        namesDict: FuzzyDict.empty(),
        autoLabelPrefix: autoLabel + " ",
        nextAutoLabel: 0,
    }
}

/**
 * Attempts to create a new concept with the given label.
 * Returns "undefined" if a concept already exists with that label.
 */
export function newConcept(registry: ConceptRegistry, label: string): Concept | "labelInUse" | "invalidLabel"
/**
 * Creates a concept with an auto-generated label.
 */
export function newConcept(registry: ConceptRegistry): Concept

export function newConcept(registry: ConceptRegistry, label?: string): Concept | "labelInUse" | "invalidLabel" {
    let myLabel: string
    if (label === undefined) {
        // Choose an automatic label name that is guaranteed to work (starts with reserved prefix)
        myLabel = `${registry.autoLabelPrefix}${++registry.nextAutoLabel}`
    }
    else {
        if (label.startsWith(registry.autoLabelPrefix)) {
            return "invalidLabel"
        }
        else {
            myLabel = label
        }
    }
    const concept = {
        label: myLabel,
        registry,
    }
    if (label === undefined) {
        // With an auto-generated label, insertion should always be successful
        FuzzyDict.insert(registry.namesDict, myLabel, concept)
        return concept
    }
    else return FuzzyDict.insert(registry.namesDict, myLabel, concept)
        ? concept
        : "labelInUse"
}

export function setLabel(concept: Concept, newLabel: string): "success" | "labelInUse" | "invalidLabel" {
    if (newLabel.startsWith(concept.registry.autoLabelPrefix)) {
        return "invalidLabel"
    }
    else {
        if (FuzzyDict.insert(concept.registry.namesDict, newLabel, concept)) {
            //FuzzyDict.remove(concept.registry.namesDict, concept.label)
            ;(concept as {label: string}).label = newLabel // remove readonly qualifier
            return "success"
        }
        else {
            return "labelInUse"
        }
    }
}

/**
 * Find the concept in the registry with the given label.
 * Returns "undefined" if such a concept does not exist.
 */
export function findConcept(registry: ConceptRegistry, label: string): Concept | undefined {
    let firstResult = undefined
    FuzzyDict.fuzzySearch(registry.namesDict, label, 0).some(result => {
        if (result.key === label) {
            firstResult = result.value
            return true
        }
    })
    return firstResult
}

/**
 * Finds all the concepts in the registry matching the given label
 * to within the given edit distance.
 */
export function findConceptsWithLabelPrefix(registry: ConceptRegistry, label: string, errorTolerance: number): SearchResult[] {
    return FuzzyDict.fuzzySearch(registry.namesDict, label, errorTolerance)
}