import * as FuzzyDict from "./libs/fuzzy-prefix-dict"

export interface ConceptRegistry {
    readonly namesDict: FuzzyDict.T<Concept>
    readonly autoLabelPrefix: string
    nextAutoLabel: number
}

export type T = ConceptRegistry

// Currently, concepts are uniquely identified by their address.
// For a distributed system, (under the hood) identity will need
// to be established via some kind of conflict-free UUID.
export interface Concept {
    readonly label: string // source of truth
    readonly registry: ConceptRegistry
}

export type SearchResult = FuzzyDict.SearchResult<Concept>

/**
 * Create a new concept registry.
 * Autogenerated concept labels will have the given label prefix.
 */
export function empty(autoLabel: string): ConceptRegistry {
    return {
        namesDict: FuzzyDict.empty(),
        autoLabelPrefix: autoLabel + " ",
        nextAutoLabel: 0,
    }
}

/**
 * Attempts to create a new concept with the given label.
 */
export function newConcept(registry: ConceptRegistry, label: string): Concept | "labelInUse" | "labelReserved"
/**
 * Creates a concept with an auto-generated label.
 */
export function newConcept(registry: ConceptRegistry): Concept

export function newConcept(registry: ConceptRegistry, label?: string): Concept | "labelInUse" | "labelReserved" {
    let myLabel: string
    if (label === undefined) {
        // Choose an automatic label name that is guaranteed to work (starts with reserved prefix)
        myLabel = `${registry.autoLabelPrefix}${++registry.nextAutoLabel}`
    }
    else {
        if (label.startsWith(registry.autoLabelPrefix)) {
            return "labelReserved"
        }
        else {
            myLabel = label
        }
    }
    const concept = {
        label: myLabel,
        registry,
    }
    if (label === undefined) {
        // With an auto-generated label, insertion should always be successful
        FuzzyDict.insert(registry.namesDict, myLabel, concept)
        return concept
    }
    else return FuzzyDict.insert(registry.namesDict, myLabel, concept)
        ? concept
        : "labelInUse"
}

export function setConceptLabel(concept: Concept, newLabel: string): "success" | "labelInUse" | "labelReserved" {
    if (newLabel.startsWith(concept.registry.autoLabelPrefix)) {
        return "labelReserved"
    }
    else {
        if (FuzzyDict.insert(concept.registry.namesDict, newLabel, concept)) {
            FuzzyDict.remove(concept.registry.namesDict, concept.label)
            ;(concept as {label: string}).label = newLabel // remove readonly qualifier
            return "success"
        }
        else {
            return "labelInUse"
        }
    }
}

/**
 * Delete the concept from its registry.
 * Returns whether the concept was found in the registry (and thus deleted).
 */
export function deleteConcept(concept: Concept): boolean {
    return FuzzyDict.remove(concept.registry.namesDict, concept.label) !== undefined
}

/**
 * Find the concept in the registry with the given label.
 * Returns "undefined" if such a concept does not exist.
 */
export function findConcept(registry: ConceptRegistry, label: string): Concept | undefined {
    let firstResult: Concept | undefined = undefined
    FuzzyDict.fuzzySearch(registry.namesDict, label, 0).some(result => {
        if (result.key === label) {
            firstResult = result.value
            return true
        }
    })
    return firstResult
}

/**
 * Finds all the concepts in the registry matching the given label
 * to within the given edit distance.
 */
export function findConceptsWithLabelPrefix(registry: ConceptRegistry, label: string, errorTolerance: number): SearchResult[] {
    return FuzzyDict.fuzzySearch(registry.namesDict, label, errorTolerance)
}