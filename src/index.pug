doctype html

head
    script(src='vue.js')
    script(src='cycle.js')

body
    div(id='app')
        h2 {{item}} is good
        ul
            li(v-for='product in products').
                {{ product }}
        p Computed thing: {{ totalProducts }}
        p Current count: {{ count }}
        button(@click='increment') Increase count
        input(type='number', v-model.number='count')
        span(:title='item').
            Hover here
        button(@click='saveState') Save
        thing(:x='count')

script.
    'use strict';
    /* global Vue */

    Vue.component('thing', {
        props: ['x'],
        template: '<li>The current count is {{ x }}</li>'
    });

    let restoredState;

    // Vue makes a copy of this data, so keeping it out of scope
    // will prevent us from accidentally linking back to it!
    {
        let products = [{x: 3}, {y: 7}, {z: 0}];
        
        let initialState = {
            item: 'Thing',
            products: products,
            count: 0,
            cursor: products[0],
            toJSON () {
                return this
            },
        }

        restoredState = (localStorage.state && localStorage.state != "undefined")
            ? {...initialState, ...JSON.retrocycle(JSON.parse(localStorage.state))}
            : initialState
    }

    new Vue({
        el: '#app',
        // "Essential" state values.
        data: restoredState,
        // Derived state values. These stay cached once computed.
        // These are read-only by default, but you can add setters as well.
        computed: {
            totalProducts () {
                return this.products.reduce((curr, x) => curr + x);
            }
        },
        // A method that runs on app start. Can be used to perform external effects.
        created () {
            // Set up save-on-close behaviour
            window.addEventListener('beforeunload', this.saveState)
            this.cursor = this.products[0]
        },
        // Methods should (only) be used to perform a state transition or an external effect.
        // They are useful for polling external state. Return values are not cached.
        methods: {
            increment () {
                this.cursor.x += 1
            },
            saveState () {
                // TODO: Have data auto-save periodically (every 10 sec?)
                localStorage.state = JSON.stringify(JSON.decycle(this.$data))
            },
        },
        // For running external effects when a "data" or "computed" property changes.
        // Use this over a computed property if you need to perform asynchronous work (e.g. an API call).
        // This is an imperative event-response model.
        watch: {
        },
    });